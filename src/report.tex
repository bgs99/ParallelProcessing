\documentclass[14pt, a4paper, oneside, final]{extarticle}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{geometry} 
\usepackage{graphicx, caption}
\usepackage{amssymb, amsmath, amsfonts}
\usepackage{xcolor, hyperref}
\usepackage{setspace, fullpage, indentfirst}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{csvsimple}

\addto\captionsrussian{\def\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}}

\geometry{left=3cm, top=2cm, right=1.5cm, bottom=2cm}
\geometry{nohead, includefoot}
\geometry{foot=4mm, footskip=8mm}
\captionsetup{labelsep=period, justification=centering}
\setlength{\parindent}{1.27cm}
\doublespacing
\emergencystretch=25pt


\makeatletter
\makeatother

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА 
\begin{document} 
\setcounter{page}{0}
\begin{center} 
\small
\footnotesize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ}\\
\footnotesize{УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}\\ 
\footnotesize{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО»}\\
\hfill \break 
\footnotesize{ФАКУЛЬТЕТ ПИИКТ}\\
\hfill \break
\hfill \break 
\hfill \break
\large{
    \textbf{Отчет по лабораторной работе №5}

    \textbf{по дисциплине Параллельные вычисления}
}

\hfill \break 
\end{center} 
\begin{flushright} 
Выполнили студенты\\
Гуляев Б. С., P42141\\
Аргынова К. А., P42191\\
\end{flushright}
\vspace*{\fill}
\begin{center}
Санкт-Петербург

2022
\end{center}
\normalsize
\thispagestyle{empty}

\clearpage
\section*{ВВЕДЕНИЕ}
\subsection*{Цель работы}
Научиться распараллеливать приложения при помощи библиотеки pthread.
\subsection*{Задачи}
\begin{enumerate}
 \item Взять в качестве исходной OpenMP-программу из ЛР-4, в которой распараллелены все этапы вычисления. Убедиться, что в этой программе корректно реализован одновременный доступ к общей переменной, используемой для вывода в консоль процента завершения программы.

 \item Изменить исходную программу так, чтобы вместо OpenMP-директив применялся стандарт «POSIX Threads»:
  \begin{itemize}
  \item необходимо изменить всю программу;
   \item допускается в качестве расписания циклов использовать «schedule static»;
   \item хотя бы один цикл распараллелить, реализовав вручную расписание «schedule dynamic» или «schedule guided».
  \end{itemize}


 \item Провести эксперименты и по результатам выполнить сравнение работы двух параллельных программ («OpenMP» и «POSIX Threads»), которое должно описывать следующие аспекты работы обеих программ (для различных $N$):
 \begin{itemize}
  \item полное время решения задачи;
  \item параллельное ускорение;
  \item доля времени, проводимого на каждом этапе вычисления («нормированная диаграмма с областями и накоплением»);
  \item количество строк кода, добавленных при распараллеливании, а также грубая оценка времени, потраченного на распараллеливание (накладные расходы программиста);
  \item остальные аспекты, которые вы выяснили самостоятельно.
 \end{itemize}
\end{enumerate}

\textbf{Вариант:} $(6*6*9) \% 47 = 42$ - гиперболический синус с последующим возведением в квадрат, модуль тангенса, возведение в степень, сортировка выбором.

\clearpage
\section*{СРЕДА ВЫПОЛНЕНИЯ}
\addcontentsline{toc}{section}{СРЕДА ВЫПОЛНЕНИЯ}

Код собирается следующими компиляторами:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item GCC 12.2.0
\end{itemize}

Процессор: AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx

Архитектура: x86\_64

Количество сокетов: 1

Количество ядер: 4

Количество потоков на ядро: 2 (дополнительные потоки выключены при замерах)

Размеры кэшей:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item L1d: 128 KiB (4 instances)
 \item L1i: 256 KiB (4 instances)
 \item L2: 2 MiB (4 instances)
 \item L3: 4 MiB (1 instance)
\end{itemize}

ОЗУ: 6 GB, без swap

ОС: Arch Linux (rolling release) Linux version 5.19.10-arch1-1

Разрядность ОС: 64 bit


\clearpage
\section*{ХОД РАБОТЫ}
\addcontentsline{toc}{section}{ХОД РАБОТЫ}
Исходный код доступен по ссылке

\url{https://github.com/bgs99/ParallelProcessing}

\clearpage

\section*{Результаты}

Были получены следующие результаты замеров времени для разных количеств потоков:

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_1.png}


\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_2.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_3.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_4.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_6.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.1/Time_complexity_threads_8.png}

На данных графиках видно, что использование библиотеки pthread вместо OMP в общем случае не дает значительного выигрыша.

Далее было расчитано параллельное ускорение:

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_1.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_2.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_3.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_4.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_6.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.2/Compare_accelerations_threads_8.png}

На данных графиках видно, что использование минимума в качестве метода отсеивания выбросов ненадежно.
Кроме того мы видим, что ввиду по большей части совпадающего времени выполнения параллельное ускорение обеих программ примерно одинаково.

Далее было рассмотрено время выполнения программ по этапам:

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_1.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_2.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_3.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_4.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_6.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab5/task3.3/exec_time_steps_threads_8.png}

На этих графиках видна ожидаемая картина: по мере роста размера входного массива растет доля времени, проводимая на самой асимптотически сложной части вычисления, сортировке.

При распараллеливании было добавлено 180 строк кода, на распараллеливание было потрачено около 4.5 часов (включая реализацию дополнительных требований в ЛР-5).

\clearpage
\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}

В результате данной работы была проведено распараллеливание программы с помощью библиотеки pthread. Было обнаружено, что использование pthread вместо OMP не дает значительных преимуществ для данной задачи.

Кроме того были обнаружены следующие факты:

\begin{itemize}
 \item Guided расписание можно реализовать без мьютексов, на CAS-цикле.
 \item Возвращаемое значение потоков в pthread бесполезно, так как требует аллокации - нельзя вернуть что-то из стека функции потока.
 \item Если с обновлением атомарной переменной не связано обновление каких-то разделяемых данных, то достаточно Relaxed ордеринга.
\end{itemize}

\end{document}
