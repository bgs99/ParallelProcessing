\documentclass[14pt, a4paper, oneside, final]{extarticle}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{geometry} 
\usepackage{graphicx, caption}
\usepackage{amssymb, amsmath, amsfonts}
\usepackage{xcolor, hyperref}
\usepackage{setspace, fullpage, indentfirst}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{csvsimple}

\addto\captionsrussian{\def\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}}

% настройки полей документа
\geometry{left=3cm, top=2cm, right=1.5cm, bottom=2cm}
\geometry{nohead, includefoot}
\geometry{foot=4mm, footskip=8mm}
\hypersetup{pdfstartview=FitH, colorlinks=true, linkcolor=black, urlcolor=black, citecolor=black}
\captionsetup{labelsep=period, justification=centering}
\setlength{\parindent}{1.27cm}
%\onehalfspacing
\doublespacing
\emergencystretch=25pt


\makeatletter
\makeatother

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА 
\begin{document} 
\setcounter{page}{0}
\begin{center} 
\small
\footnotesize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ}\\
\footnotesize{УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}\\ 
\footnotesize{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО»}\\
\hfill \break 
\footnotesize{ФАКУЛЬТЕТ ПИИКТ}\\
\hfill \break
\hfill \break 
\hfill \break
\large{
    \textbf{Отчет по лабораторной работе №1}

    \textbf{по дисциплине Параллельные вычисления}
}

\hfill \break 
\end{center} 
\begin{flushright} 
Выполнил студент\\
группы P42141\\
Гуляев Богдан Сергеевич\\
\end{flushright}
\vspace*{\fill}
\begin{center}
Санкт-Петербург

2022
\end{center}
\normalsize
\thispagestyle{empty} 
\clearpage
\def\contentsname{ОГЛАВЛЕНИЕ}
\tableofcontents 

\clearpage
\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}
\subsection*{Цель работы}
Получить опыт работы со средствами автоматического распараллеливания вычислений и оценки ее эффективности.
\subsection*{Задачи}
\begin{enumerate}
 \item На компьютере с многоядерным процессором установить ОС Linux и компилятор GCC версии не ниже 4.7.2.
 Минимальное количество ядер при использовании виртуальной машины - 2.
 \item На языке Cи написать консольную программу lab1.c, решающую
задачу, указанную в п. 4 (см. ниже). В программе нельзя использовать библиотечные функции сортировки, выполнения матричных операций и расчёта статистических величин. В программе нельзя использовать библиотечные функции, отсутствующие в стандартных заголовочных файлах stdio.h, stdlib.h, math.h, sys/time.h. Задача должна решаться 100 раз с разными начальными значениями генератора случайных чисел (ГСЧ).
 \item Скомпилировать написанную программу без использования автоматического распараллеливания с помощью следующей команды:

\lstinline[language=Bash]{/home/user/gcc -O3 -Wall -Werror -o lab1-seq lab1.c}
 \item Скомпилировать написанную программу, используя встроенное в gcc средство автоматического распараллеливания Graphite с помощью следующей команды:

 \begin{lstlisting}[language=Bash]
 /home/user/gcc -O3 -Wall -Werror \
    -floop-parallelize-all \
    -ftree-parallelize-loops=K \
    lab1.c -o lab1-par-K
 \end{lstlisting}
%\end{lstlisting}
 (переменной K поочерёдно присвоить хотя бы 4 значения: 1, меньше количества ядер, равное количеству физических ядер и больше количества физических ядер).
 \item В результате получится одна нераспараллеленная программа и че-
тыре или более распараллеленных.
 \item Закрыть все работающие в операционной системе прикладные программы, чтобы они не влияли на результаты последующих экспериментов. При использовании ноутбука необходимо иметь постоянное подключение к сети питания, на время проведения эксперимента.
 \item Запускать файл lab1-seq из командной строки, увеличивая значения $N$ до значения $N1$, при котором время выполнения превысит 0.01 с. Подобным образом найти значение $N=N2$, при котором время выполнения превысит 5 с.
 \item Используя найденные значения $N1$ и $N2$, выполнить следующие эксперименты (для автоматизации проведения экспериментов рекомендуется написать скрипт):
    \begin{itemize}
        \item запускать lab1-seq для значений

        $N = N1, N1 + \Delta, N1 + 2\Delta, N1 + 3\Delta, ..., N2$

        и записывать получающиеся значения времени $delta\_ms(N)$ в функцию $seq(N)$;
        \item запускать lab1-par-K для значений

        $N = N1, N1 + \Delta, N1 + 2\Delta, N1 + 3\Delta, ..., N2$

        и записывать получающиеся значения времени $delta\_ms(N)$ в функцию $par-K(N)$;
        значение $\Delta$ выбрать так: $\Delta = (N2 - N1) / 10$.
    \end{itemize}
 \item Провести верификацию значения $X$. Добавить в конец цикла вывод значения $X$ и изменить количество экспериментов на 5. Сравнить значения $X$ для распараллеленной программы и не распараллеленной.
 \item Написать отчёт о проделанной работе.
 \item Подготовиться к устным вопросам на защите.
 \item Найти вычислительную сложность алгоритма до и после распараллеливания, сравнить полученные результаты.
 \item \textbf{Необязательное задание №1 (для получения оценки «четыре» и «пять»).}

 Провести аналогичные описанным эксперименты, используя вместо gcc компилятор Solaris Studio (или любой другой на своё усмотрение). При компиляции следует использовать следующие опции для автоматического распараллеливания:

 \lstinline[language=Bash]{solarisstudio -cc -O3 -xautopar -xloopinfo lab1.c}.
 \item \textbf{Необязательное задание №2 (для получения оценки «пять»).}

 Это задание выполняется только после выполнения предыдущего пункта. Провести аналогичные описанным эксперименты, используя вместо gcc компилятор Intel ICC (или любой другой на своё усмотрение). В ICC следует при компиляции использовать следующие опции для автоматического распараллеливания:

 \begin{lstlisting}[language=Bash]
 icc -parallel-par-threashold0 \
    -par-num-threads=K \
    -o lab1-icc-par-K lab1.c
 \end{lstlisting}
%\end{lstlisting}
\end{enumerate}

\clearpage
\section*{СРЕДА ВЫПОЛНЕНИЯ}
\addcontentsline{toc}{section}{СРЕДА ВЫПОЛНЕНИЯ}

Код собирается следующими компиляторами:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item GCC 12.2.0
 \item ICC 2021.6.0 20220226
 \item SunCC OSS 12.3
\end{itemize}

Процессор: AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx

Архитектура: x86\_64

Количество сокетов: 1

Количество ядер: 4

Количество потоков на ядро: 2 (дополнительные потоки выключены при замерах)

Размеры кэшей:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item L1d: 128 KiB (4 instances)
 \item L1i: 256 KiB (4 instances)
 \item L2: 2 MiB (4 instances)
 \item L3: 4 MiB (1 instance)
\end{itemize}

ОЗУ: 6 GB, без swap

ОС: Arch Linux (rolling release) Linux version 5.19.10-arch1-1

Разрядность ОС: 64 bit


\clearpage
\section*{ХОД РАБОТЫ}
\addcontentsline{toc}{section}{ХОД РАБОТЫ}
Исходный код доступен по ссылке

\url{https://github.com/bgs99/ParallelProcessing}

\clearpage
GCC, время в мс

\csvautotabular{../build/lab1-gcc.csv}

GCC, параллельное ускорение

\csvautotabular{../build/lab1-gcc-eff.csv}

\begin{figure}[ht!]

\includegraphics[width=.8\linewidth]{../build/lab1-gcc.png}
\end{figure}

Согласно результатам замеров, при использовании GCC прирост производительности при использовании небольшого ($K < 4$) количества потоков незначителен, на небольших массивах данных заметно даже ее уменьшение.

Наибольшая проиводительность наблюдается при $K=4$, при $K$, превышающему количество ядер заметно ожидаемое снижение производительности, вызванное накладными расходами на управление потоками.

Величины параллельного ускорения незначительны ввиду высокой доли нераспараллеливаемого кода во времени выполнения. Данный эффект, скорее всего, обуславливается наличием алгоритма сортировки с квадратической сложностью, не поддерживающего распараллеливание.


\clearpage
ICC, время в мс

\csvautotabular{../build/lab1-icc.csv}

ICC, параллельное ускорение

\csvautotabular{../build/lab1-icc-eff.csv}


\begin{figure}[ht!]

\includegraphics[width=.8\linewidth]{../build/lab1-icc.png}
\end{figure}
При использовании ICC наибольшая проиводительность среди измеренных наблюдается при $K=2$, при $K$, превышающему количество ядер заметно значительное снижение производительности, вызванное накладными расходами на управление потоками. При этом при $K$, равном количеству ядер, наблюдается снижение производительности по сравнению с нераспараллеленной версией, в отсличие от GCC, что демонстрирует значительность этих накладных расходов.

Величины параллельного ускорения незначительны ввиду высокой доли нераспараллеливаемого кода во времени выполнения. Данный эффект, скорее всего, обуславливается наличием алгоритма сортировки с квадратической сложностью, не поддерживающего распараллеливание.
\clearpage
SunCC, время в мс

\csvautotabular{../build/lab1-suncc.csv}

SunCC, параллельное ускорение

\csvautotabular{../build/lab1-suncc-eff.csv}

\begin{figure}[ht!]

\includegraphics[width=.8\linewidth]{../build/lab1-suncc.png}
\end{figure}

При компиляции исходного кода SunCC вывел предупреждения для всех циклов в программе о невозможности их распараллеливания.

В табличных данных и на соответствующем графике можно убедиться, что полученные результаты ожидаемо не различаются.

\clearpage
\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}
В результате данной работы были применены 3 раличных компилятора (GCC, ICC, SunCC), поддерживащих автоматическое распараллеливание. Были проведены замеры производительности и параллельного ускорения результирующих программ при различном количестве потоков.

Было обнаружено, что компилятор SunCC не справляется с распараллеливанием кода, успешно распараллеленного другими используемыми компиляторами.

Большинство замеров показывают более высокую производительность при количестве потоков равном, или меньшем количеству ядер.

При этом величины параллельного ускорения во всех замерах незначительны ввиду высокой доли нераспараллеливаемого кода во времени выполнения. Данный эффект, скорее всего, обуславливается наличием алгоритма сортировки с квадратической сложностью, не поддерживающего распараллеливание.
\end{document}
