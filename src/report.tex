\documentclass[14pt, a4paper, oneside, final]{extarticle}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{geometry} 
\usepackage{graphicx, caption}
\usepackage{amssymb, amsmath, amsfonts}
\usepackage{xcolor, hyperref}
\usepackage{setspace, fullpage, indentfirst}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{csvsimple}

\addto\captionsrussian{\def\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}}

% настройки полей документа
\geometry{left=3cm, top=2cm, right=1.5cm, bottom=2cm}
\geometry{nohead, includefoot}
\geometry{foot=4mm, footskip=8mm}
\hypersetup{pdfstartview=FitH, colorlinks=true, linkcolor=black, urlcolor=black, citecolor=black}
\captionsetup{labelsep=period, justification=centering}
\setlength{\parindent}{1.27cm}
%\onehalfspacing
\doublespacing
\emergencystretch=25pt


\makeatletter
\makeatother

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА 
\begin{document} 
\setcounter{page}{0}
\begin{center} 
\small
\footnotesize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ}\\
\footnotesize{УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}\\ 
\footnotesize{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО»}\\
\hfill \break 
\footnotesize{ФАКУЛЬТЕТ ПИИКТ}\\
\hfill \break
\hfill \break 
\hfill \break
\large{
    \textbf{Отчет по лабораторной работе №2}

    \textbf{по дисциплине Параллельные вычисления}
}

\hfill \break 
\end{center} 
\begin{flushright} 
Выполнили студенты\\
Гуляев Б. С., P42141\\
Аргынова К. А., P42191\\
\end{flushright}
\vspace*{\fill}
\begin{center}
Санкт-Петербург

2022
\end{center}
\normalsize
\thispagestyle{empty} 
\clearpage
\def\contentsname{ОГЛАВЛЕНИЕ}
\tableofcontents 

\clearpage
\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}
\subsection*{Цель работы}
Получить опыт работы с параллельными библиотеками и оценки их эффективности.
\subsection*{Задачи}
\begin{enumerate}
 \item В исходном коде программы, полученной в результате выполнения
лабораторной работы №1, нужно на этапах Map и Merge все циклы
с вызовами математических функций заменить их векторными аналогами из библиотеки «AMD Framewave». При выборе конкретной Framewave-функции необходимо убедиться, что она помечена как MT (Multi-Threaded),
т.е. распараллеленная.
\item Добавить в начало программы вызов Framewave-функции

 $SetNumThreads(M)$ для установки количества создаваемых параллельной библиотекой потоков, задействуемых при выполнении распараллеленных Framewave-функций. Нужное число M следует устанавливать из параметра командной строки (argv) для удобства автоматизации экспериментов.
 \item Скомпилировать программу, не применяя опции автоматического распараллеливания, использованные в лабораторной работе №1. Провести эксперименты с полученной программой для тех же значений $N1$ и $N2$, которые использовались в лабораторной работе №1, при $M = 1, 2, ..., K$, где $K$ – количество процессоров (ядер) на экспериментальном стенде.
 \item Сравнить полученные результаты с результатами лабораторной работы №1: на графиках показать, как изменилось время выполнения программы, параллельное ускорение и параллельная эффективность.
 \item Написать отчёт о проделанной работе.
 \item Подготовиться к устным вопросам на защите.
 \item \textbf{Необязательное задание №1 (для получения оценки «четыре» и «пять»).}

 Исследовать параллельное ускорение для различных знаений $M > K$, т.е. оценить накладные расходы при создании чрезмерного большого количества потоков. Для иллюстрации того, что программа действительно распараллелилась, привести график загрузки процессора (ядер) во время выполнения программы при $N = N2$ для всех использованных M . Для получения графика можно как написать скрипт, так и просто сделать скриншот диспетчера задач, указав на скриншоте моменты начала и окончания эксперимента (в отчёте нужно привести текст скрипта или название использованного диспетчера).
 \item \textbf{Необязательное задание №2 (для получения оценки «пять»).}

 Это задание выполняется только после выполнения предыдущего пункта.
Используя закон Амдала, рассчитать коэффициент распараллеливания для всех экспериментов и привести его на графиках. Прокомментировать полученные результаты.
\end{enumerate}

\textbf{Вариант:} $(6*6*9) \% 47 = 42$ - гиперболический синус с последующим возведением в квадрат, модуль тангенса, возведение в степень, сортировка выбором.

\clearpage
\section*{СРЕДА ВЫПОЛНЕНИЯ}
\addcontentsline{toc}{section}{СРЕДА ВЫПОЛНЕНИЯ}

Код собирается следующими компиляторами:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item GCC 12.2.0
 \item ICC 2021.6.0 20220226
 \item SunCC OSS 12.3
\end{itemize}

Процессор: AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx

Архитектура: x86\_64

Количество сокетов: 1

Количество ядер: 4

Количество потоков на ядро: 2 (дополнительные потоки выключены при замерах)

Размеры кэшей:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item L1d: 128 KiB (4 instances)
 \item L1i: 256 KiB (4 instances)
 \item L2: 2 MiB (4 instances)
 \item L3: 4 MiB (1 instance)
\end{itemize}

ОЗУ: 6 GB, без swap

ОС: Arch Linux (rolling release) Linux version 5.19.10-arch1-1

Разрядность ОС: 64 bit


\clearpage
\section*{ХОД РАБОТЫ}
\addcontentsline{toc}{section}{ХОД РАБОТЫ}
Исходный код доступен по ссылке

\url{https://github.com/bgs99/ParallelProcessing}

\clearpage

\section*{Конфигурация}

Для применения библиотеки AMD Framewave были скачаны файлы библиотеки со страницы AMD Framewave на SourceForge.

Далее, для каждого $*.so$ файла были сделаны слабые ссылки с именем без версии, и с только мажорной версией, для упрощения разработки и запуска. Полученное содержимое директории представлено ниже:
 \begin{lstlisting}[language=Bash]
$ ls
libfwBase.so    libfwBase.so.1.3.1  libfwImage.so.1      libfwJPEG.so    libfwJPEG.so.1.3.1  libfwSignal.so.1      libfwVideo.so    libfwVideo.so.1.3.1
libfwBase.so.1  libfwImage.so       libfwImage.so.1.3.1  libfwJPEG.so.1  libfwSignal.so      libfwSignal.so.1.3.1  libfwVideo.so.1
 \end{lstlisting}
 %\end{lstlisting}

 Путь к директории с AMD Framewave был добавлен в $include\_directories$ проекта, а директория с библиотеками - в $link\_directories$.

\section*{Результаты}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/delta_par_1.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/delta_par_2.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/delta_par_4.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/delta_par_6.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/acceleration_par_2.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/acceleration_par_4.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/acceleration_par_6.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/efficiency_par_2.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/efficiency_par_4.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task4/efficiency_par_6.png}

Как видно на графиках, параллелизация с помощью AMD Framewave не принесла заметного улучшения, что связано с тем, что большую часть времени приложение проводит в квадратичной по сложности сортировке.

Однако стоит отметить, что при небольших значениях $N$ и $M > K$ AMD Framewave показывает значительное преимущество. Предположительно это связано с тем, что AMD Framewave отказывается создавать больше потоков, чем позволяет аппаратный параллелелизм.

Данное предположение поддерживает также график замера параллельного ускорения для $M > K$:

\includegraphics[width=.8\linewidth]{../report/tasks/task7/parallel_accelerations.png}

Для проверки распараллеливания были собраны замеры нагрузки CPU, которые показали, что во время выаолнения нагружено только 1 ядро (см. выше - большую часть времени приложение проводит в сортировке):

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-1-stat.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-2-stat.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-3-stat.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-4-stat.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-6-stat.png}

\includegraphics[width=.8\linewidth]{../report/tasks/task7/cpu_utilization/lab2-8-stat.png}

Для замеров использовалась утилита $mpstat$ с интервалом в 1 секунду.

Были проведены расчеты коэффициента параллелизма кода на основании проведенных экспериментов:

\includegraphics[width=.8\linewidth]{../report/tasks/task8/par_coefficients.png}

На графике видно, что в пределах погрешности данный коэффициент равен 0.

Отрицательные значения на графике связаны с накладными расходами на создание потоков, не учитываемые в методе Амдала, а также с погрешностью измерения времени выполнения.

\clearpage
\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}
В результате данной работы была применена библиотека AMD Framewave для распараллеливания вычислений приложения и были проведены замеры производительности и сравнение с результатами ЛР №1.

Было обнаружено, что распараллеливание неэффективно ввиду сравнительно высокой алгоритмической сложности нераспараллеленного кода.

Было также отмечено, что использование AMD Framewave позволяет избежать ухудшения производительности на небольших наборах данных при выделении количества потоков, превышающего аппаратный параллелелизм.
\end{document}
