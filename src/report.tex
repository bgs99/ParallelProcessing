\documentclass[14pt, a4paper, oneside, final]{extarticle}

\usepackage{cmap}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{geometry} 
\usepackage{graphicx, caption}
\usepackage{amssymb, amsmath, amsfonts}
\usepackage{xcolor, hyperref}
\usepackage{setspace, fullpage, indentfirst}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{csvsimple}

\addto\captionsrussian{\def\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}}

\geometry{left=3cm, top=2cm, right=1.5cm, bottom=2cm}
\geometry{nohead, includefoot}
\geometry{foot=4mm, footskip=8mm}
\captionsetup{labelsep=period, justification=centering}
\setlength{\parindent}{1.27cm}
\doublespacing
\emergencystretch=25pt


\makeatletter
\makeatother

% НАЧАЛО ТИТУЛЬНОГО ЛИСТА 
\begin{document} 
\setcounter{page}{0}
\begin{center} 
\small
\footnotesize{ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ}\\
\footnotesize{УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ}\\ 
\footnotesize{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО»}\\
\hfill \break 
\footnotesize{ФАКУЛЬТЕТ ПИИКТ}\\
\hfill \break
\hfill \break 
\hfill \break
\large{
    \textbf{Отчет по лабораторной работе №6}

    \textbf{по дисциплине Параллельные вычисления}
}

\hfill \break 
\end{center} 
\begin{flushright} 
Выполнили студенты\\
Гуляев Б. С., P42141\\
Аргынова К. А., P42191\\
\end{flushright}
\vspace*{\fill}
\begin{center}
Санкт-Петербург

2022
\end{center}
\normalsize
\thispagestyle{empty} 
\clearpage
\def\contentsname{ОГЛАВЛЕНИЕ}
\tableofcontents 

\clearpage
\section*{ВВЕДЕНИЕ}
\subsection*{Цель работы}
Научится работать с технологией OpenCL.
\subsection*{Задачи}
\begin{enumerate}
 \item Вам необходимо реализовать два этапа вашей программы из предыдущих лабораторных работ. При этом вычисления можно проводить как на CPU, так и на GPU (на своё усмотрение, но GPU предпочтительнее).

 \item Расчёт доверительного интервала.

 \item Посчитать время 2 способами: с помощью profiling и с помощью обычного замера (как в предыдущих заданиях).

 \item Оценить накладные расходы, такие как доля времени, проводимого на каждом этапе вычисления («нормированная диаграмма с областями и накоплением»), число строк кода, добавленных при распараллеливании, а также грубая оценка времени, потраченного на распараллеливание (накладные расходы программиста), и т.п.
\end{enumerate}

\textbf{Вариант:} $(6*6*9) \% 47 = 42$ - гиперболический синус с последующим возведением в квадрат, модуль тангенса, возведение в степень, сортировка выбором.

\clearpage
\section*{СРЕДА ВЫПОЛНЕНИЯ}
\addcontentsline{toc}{section}{СРЕДА ВЫПОЛНЕНИЯ}

Код собирается следующими компиляторами:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item GCC 12.2.0
\end{itemize}

Процессор: AMD Ryzen 5 3550H with Radeon Vega Mobile Gfx

Архитектура: x86\_64

Количество сокетов: 1

Количество ядер: 4

Количество потоков на ядро: 2 (дополнительные потоки выключены при замерах)

Размеры кэшей:
\begin{itemize}
 \setlength{\itemindent}{3em}
 \item L1d: 128 KiB (4 instances)
 \item L1i: 256 KiB (4 instances)
 \item L2: 2 MiB (4 instances)
 \item L3: 4 MiB (1 instance)
\end{itemize}

ОЗУ: 6 GB, без swap

ОС: Arch Linux (rolling release) Linux version 5.19.10-arch1-1

Разрядность ОС: 64 bit

Результат clinfo доступен в репозитории с кодом.

\clearpage
\section*{ХОД РАБОТЫ}
\addcontentsline{toc}{section}{ХОД РАБОТЫ}
Исходный код доступен по ссылке

\url{https://github.com/bgs99/ParallelProcessing}

\clearpage

\section*{Результаты}

В ходе работы были распараллелены все этапы вычисления кроме Generate. Для этапов Sort и Reduce был проварьирован параметр work items, которым вычисление делилось между ядрами:

\includegraphics[width=.8\linewidth]{../build/graphs/lab6/compare_exec_times.png}

Как видно на данном графике, после 100 WI прирост производительности не значителен, однако при близком рассмотрении в среднем 200 WI быстрее, поэтому он будет использован в дальнейшем для сравнения.

Для начала сравним с самой быстрой версией на текущий момент: результатом ЛР 4:

\includegraphics[width=.8\linewidth]{../build/graphs/lab6/task2.2/compare_min_accelerations.png}

\includegraphics[width=.8\linewidth]{../build/graphs/lab6/task2.2/compare_stud_intervals.png}

На данном графике видно, что с ростом N версия ЛР 6 получает значительное преимущество в параллельном ускорении.

Это скорее всего связано с высоким уровнем параллелизма, доступным при использовании графического ускорителя.

Кроме того стоит заметить что замеры производительности ЛР 6 гораздо стаблильнее, что скорее всего связано с использованием менее занятого графического ускорителя вместо центрального процессора.

Далее сравним распределение времени по этапам:

\includegraphics[width=.8\linewidth]{../build/graphs/lab6/task2.3/Comparison of lab 4 and lab 6 execution steps by N.png}

Как видно на данном графике, в ЛР 6 по сравнению с ЛР 4 доля времени, занимаемая сортировкой, немного ниже. Это, опять же, вероятно связано со значительно большим уровнем параллелизма на данном этапе. Вместо этого в ЛР 6 значительную часть времени при больших N занимает этап генерации, не подвергшийся распараллеливанию.

Результирующая программа ЛР 6 вместе с OpenCL кодом составляет 447 строк против 145 строк ЛР 4 и 443 строк ЛР 5.

Субъективно, модель вычислений OpenCL больше напоминает OpenMP чем pthread, и при освоении довольно интуитивна. Однако освоение занимает значительное время, дополнительно увеличивающееся из-за плохой имплементации стандарта производителями графических ускорителей и их драйверов (гори в аду, Nvidia). Итого, переработка приложения под OpenCL заняла около 9 часов.

\clearpage
\section*{ВЫВОД}
\addcontentsline{toc}{section}{ВЫВОД}

В результате данной работы была переписана программа на технологию OpenCL.

Были получены навыки программирования на OpenCL, включая замер времени с помощью profiling.
\end{document}
